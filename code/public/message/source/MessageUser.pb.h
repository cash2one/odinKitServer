// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageUser.proto

#ifndef PROTOBUF_MessageUser_2eproto__INCLUDED
#define PROTOBUF_MessageUser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MessageUser_2eproto();
void protobuf_AssignDesc_MessageUser_2eproto();
void protobuf_ShutdownFile_MessageUser_2eproto();

class UserLogin;
class UserDisplace;
class ConnectGate;
class UserHeartResponse;
class UserCheck;
class GuestCheck;
class ClientLogin;
class UserLogout;
class UserHeartRequest;

// ===================================================================

class UserLogin : public ::google::protobuf::Message {
 public:
  UserLogin();
  virtual ~UserLogin();

  UserLogin(const UserLogin& from);

  inline UserLogin& operator=(const UserLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogin& default_instance();

  void Swap(UserLogin* other);

  // implements Message ----------------------------------------------

  UserLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogin& from);
  void MergeFrom(const UserLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional int32 world = 2;
  inline bool has_world() const;
  inline void clear_world();
  static const int kWorldFieldNumber = 2;
  inline ::google::protobuf::int32 world() const;
  inline void set_world(::google::protobuf::int32 value);

  // optional int32 server = 3;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 3;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string key = 5;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 5;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:Message.UserLogin)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_world();
  inline void clear_has_world();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int32 world_;
  ::google::protobuf::int32 server_;
  ::std::string* type_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserLogin* default_instance_;
};
// -------------------------------------------------------------------

class UserDisplace : public ::google::protobuf::Message {
 public:
  UserDisplace();
  virtual ~UserDisplace();

  UserDisplace(const UserDisplace& from);

  inline UserDisplace& operator=(const UserDisplace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDisplace& default_instance();

  void Swap(UserDisplace* other);

  // implements Message ----------------------------------------------

  UserDisplace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserDisplace& from);
  void MergeFrom(const UserDisplace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Message.UserDisplace)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserDisplace* default_instance_;
};
// -------------------------------------------------------------------

class ConnectGate : public ::google::protobuf::Message {
 public:
  ConnectGate();
  virtual ~ConnectGate();

  ConnectGate(const ConnectGate& from);

  inline ConnectGate& operator=(const ConnectGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectGate& default_instance();

  void Swap(ConnectGate* other);

  // implements Message ----------------------------------------------

  ConnectGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectGate& from);
  void MergeFrom(const ConnectGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional int64 key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::int64 key() const;
  inline void set_key(::google::protobuf::int64 value);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 server = 5;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 5;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.ConnectGate)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_server();
  inline void clear_has_server();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int64 key_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static ConnectGate* default_instance_;
};
// -------------------------------------------------------------------

class UserHeartResponse : public ::google::protobuf::Message {
 public:
  UserHeartResponse();
  virtual ~UserHeartResponse();

  UserHeartResponse(const UserHeartResponse& from);

  inline UserHeartResponse& operator=(const UserHeartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHeartResponse& default_instance();

  void Swap(UserHeartResponse* other);

  // implements Message ----------------------------------------------

  UserHeartResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserHeartResponse& from);
  void MergeFrom(const UserHeartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 stime = 1;
  inline bool has_stime() const;
  inline void clear_stime();
  static const int kStimeFieldNumber = 1;
  inline ::google::protobuf::int64 stime() const;
  inline void set_stime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Message.UserHeartResponse)
 private:
  inline void set_has_stime();
  inline void clear_has_stime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 stime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserHeartResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserCheck : public ::google::protobuf::Message {
 public:
  UserCheck();
  virtual ~UserCheck();

  UserCheck(const UserCheck& from);

  inline UserCheck& operator=(const UserCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCheck& default_instance();

  void Swap(UserCheck* other);

  // implements Message ----------------------------------------------

  UserCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserCheck& from);
  void MergeFrom(const UserCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // optional string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string ticket = 3;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 3;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // optional int32 client = 4;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 4;
  inline ::google::protobuf::int32 client() const;
  inline void set_client(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.UserCheck)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_client();
  inline void clear_has_client();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::google::protobuf::int32 server_;
  ::google::protobuf::int32 client_;
  ::std::string* ticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserCheck* default_instance_;
};
// -------------------------------------------------------------------

class GuestCheck : public ::google::protobuf::Message {
 public:
  GuestCheck();
  virtual ~GuestCheck();

  GuestCheck(const GuestCheck& from);

  inline GuestCheck& operator=(const GuestCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestCheck& default_instance();

  void Swap(GuestCheck* other);

  // implements Message ----------------------------------------------

  GuestCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestCheck& from);
  void MergeFrom(const GuestCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional int32 server = 2;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 2;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.GuestCheck)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_server();
  inline void clear_has_server();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_;
  ::google::protobuf::int32 server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static GuestCheck* default_instance_;
};
// -------------------------------------------------------------------

class ClientLogin : public ::google::protobuf::Message {
 public:
  ClientLogin();
  virtual ~ClientLogin();

  ClientLogin(const ClientLogin& from);

  inline ClientLogin& operator=(const ClientLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLogin& default_instance();

  void Swap(ClientLogin* other);

  // implements Message ----------------------------------------------

  ClientLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLogin& from);
  void MergeFrom(const ClientLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional int64 key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::int64 key() const;
  inline void set_key(::google::protobuf::int64 value);

  // optional int32 server = 3;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 3;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // optional string accesstoken = 4;
  inline bool has_accesstoken() const;
  inline void clear_accesstoken();
  static const int kAccesstokenFieldNumber = 4;
  inline const ::std::string& accesstoken() const;
  inline void set_accesstoken(const ::std::string& value);
  inline void set_accesstoken(const char* value);
  inline void set_accesstoken(const char* value, size_t size);
  inline ::std::string* mutable_accesstoken();
  inline ::std::string* release_accesstoken();
  inline void set_allocated_accesstoken(::std::string* accesstoken);

  // @@protoc_insertion_point(class_scope:Message.ClientLogin)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_accesstoken();
  inline void clear_has_accesstoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int64 key_;
  ::std::string* accesstoken_;
  ::google::protobuf::int32 server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static ClientLogin* default_instance_;
};
// -------------------------------------------------------------------

class UserLogout : public ::google::protobuf::Message {
 public:
  UserLogout();
  virtual ~UserLogout();

  UserLogout(const UserLogout& from);

  inline UserLogout& operator=(const UserLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogout& default_instance();

  void Swap(UserLogout* other);

  // implements Message ----------------------------------------------

  UserLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogout& from);
  void MergeFrom(const UserLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Message.UserLogout)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserLogout* default_instance_;
};
// -------------------------------------------------------------------

class UserHeartRequest : public ::google::protobuf::Message {
 public:
  UserHeartRequest();
  virtual ~UserHeartRequest();

  UserHeartRequest(const UserHeartRequest& from);

  inline UserHeartRequest& operator=(const UserHeartRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHeartRequest& default_instance();

  void Swap(UserHeartRequest* other);

  // implements Message ----------------------------------------------

  UserHeartRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserHeartRequest& from);
  void MergeFrom(const UserHeartRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Message.UserHeartRequest)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MessageUser_2eproto();
  friend void protobuf_AssignDesc_MessageUser_2eproto();
  friend void protobuf_ShutdownFile_MessageUser_2eproto();

  void InitAsDefaultInstance();
  static UserHeartRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// UserLogin

// optional int64 uid = 1;
inline bool UserLogin::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogin::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogin::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 UserLogin::uid() const {
  return uid_;
}
inline void UserLogin::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 world = 2;
inline bool UserLogin::has_world() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLogin::set_has_world() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLogin::clear_has_world() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLogin::clear_world() {
  world_ = 0;
  clear_has_world();
}
inline ::google::protobuf::int32 UserLogin::world() const {
  return world_;
}
inline void UserLogin::set_world(::google::protobuf::int32 value) {
  set_has_world();
  world_ = value;
}

// optional int32 server = 3;
inline bool UserLogin::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLogin::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLogin::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLogin::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 UserLogin::server() const {
  return server_;
}
inline void UserLogin::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// optional string type = 4;
inline bool UserLogin::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLogin::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLogin::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLogin::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& UserLogin::type() const {
  return *type_;
}
inline void UserLogin::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void UserLogin::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void UserLogin::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* UserLogin::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 5;
inline bool UserLogin::has_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLogin::set_has_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLogin::clear_has_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLogin::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& UserLogin::key() const {
  return *key_;
}
inline void UserLogin::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void UserLogin::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void UserLogin::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* UserLogin::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserDisplace

// optional int64 uid = 1;
inline bool UserDisplace::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDisplace::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDisplace::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDisplace::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 UserDisplace::uid() const {
  return uid_;
}
inline void UserDisplace::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// ConnectGate

// optional int64 uid = 1;
inline bool ConnectGate::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectGate::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectGate::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectGate::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 ConnectGate::uid() const {
  return uid_;
}
inline void ConnectGate::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int64 key = 2;
inline bool ConnectGate::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectGate::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectGate::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectGate::clear_key() {
  key_ = GOOGLE_LONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::int64 ConnectGate::key() const {
  return key_;
}
inline void ConnectGate::set_key(::google::protobuf::int64 value) {
  set_has_key();
  key_ = value;
}

// optional string ip = 3;
inline bool ConnectGate::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectGate::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectGate::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectGate::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ConnectGate::ip() const {
  return *ip_;
}
inline void ConnectGate::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ConnectGate::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ConnectGate::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectGate::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ConnectGate::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectGate::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 4;
inline bool ConnectGate::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectGate::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectGate::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectGate::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ConnectGate::port() const {
  return port_;
}
inline void ConnectGate::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 server = 5;
inline bool ConnectGate::has_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectGate::set_has_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectGate::clear_has_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectGate::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 ConnectGate::server() const {
  return server_;
}
inline void ConnectGate::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// -------------------------------------------------------------------

// UserHeartResponse

// optional int64 stime = 1;
inline bool UserHeartResponse::has_stime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHeartResponse::set_has_stime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHeartResponse::clear_has_stime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHeartResponse::clear_stime() {
  stime_ = GOOGLE_LONGLONG(0);
  clear_has_stime();
}
inline ::google::protobuf::int64 UserHeartResponse::stime() const {
  return stime_;
}
inline void UserHeartResponse::set_stime(::google::protobuf::int64 value) {
  set_has_stime();
  stime_ = value;
}

// -------------------------------------------------------------------

// UserCheck

// optional int32 server = 1;
inline bool UserCheck::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCheck::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCheck::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCheck::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 UserCheck::server() const {
  return server_;
}
inline void UserCheck::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// optional string userid = 2;
inline bool UserCheck::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserCheck::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserCheck::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserCheck::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserCheck::userid() const {
  return *userid_;
}
inline void UserCheck::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserCheck::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserCheck::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCheck::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UserCheck::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserCheck::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ticket = 3;
inline bool UserCheck::has_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserCheck::set_has_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserCheck::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserCheck::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& UserCheck::ticket() const {
  return *ticket_;
}
inline void UserCheck::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void UserCheck::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void UserCheck::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCheck::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* UserCheck::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserCheck::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 client = 4;
inline bool UserCheck::has_client() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserCheck::set_has_client() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserCheck::clear_has_client() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserCheck::clear_client() {
  client_ = 0;
  clear_has_client();
}
inline ::google::protobuf::int32 UserCheck::client() const {
  return client_;
}
inline void UserCheck::set_client(::google::protobuf::int32 value) {
  set_has_client();
  client_ = value;
}

// -------------------------------------------------------------------

// GuestCheck

// optional string device = 1;
inline bool GuestCheck::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuestCheck::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuestCheck::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuestCheck::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& GuestCheck::device() const {
  return *device_;
}
inline void GuestCheck::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void GuestCheck::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void GuestCheck::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GuestCheck::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* GuestCheck::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GuestCheck::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 server = 2;
inline bool GuestCheck::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuestCheck::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuestCheck::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuestCheck::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 GuestCheck::server() const {
  return server_;
}
inline void GuestCheck::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// -------------------------------------------------------------------

// ClientLogin

// optional int64 uid = 1;
inline bool ClientLogin::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLogin::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLogin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLogin::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 ClientLogin::uid() const {
  return uid_;
}
inline void ClientLogin::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int64 key = 2;
inline bool ClientLogin::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientLogin::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientLogin::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientLogin::clear_key() {
  key_ = GOOGLE_LONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::int64 ClientLogin::key() const {
  return key_;
}
inline void ClientLogin::set_key(::google::protobuf::int64 value) {
  set_has_key();
  key_ = value;
}

// optional int32 server = 3;
inline bool ClientLogin::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientLogin::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientLogin::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientLogin::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 ClientLogin::server() const {
  return server_;
}
inline void ClientLogin::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// optional string accesstoken = 4;
inline bool ClientLogin::has_accesstoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientLogin::set_has_accesstoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientLogin::clear_has_accesstoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientLogin::clear_accesstoken() {
  if (accesstoken_ != &::google::protobuf::internal::kEmptyString) {
    accesstoken_->clear();
  }
  clear_has_accesstoken();
}
inline const ::std::string& ClientLogin::accesstoken() const {
  return *accesstoken_;
}
inline void ClientLogin::set_accesstoken(const ::std::string& value) {
  set_has_accesstoken();
  if (accesstoken_ == &::google::protobuf::internal::kEmptyString) {
    accesstoken_ = new ::std::string;
  }
  accesstoken_->assign(value);
}
inline void ClientLogin::set_accesstoken(const char* value) {
  set_has_accesstoken();
  if (accesstoken_ == &::google::protobuf::internal::kEmptyString) {
    accesstoken_ = new ::std::string;
  }
  accesstoken_->assign(value);
}
inline void ClientLogin::set_accesstoken(const char* value, size_t size) {
  set_has_accesstoken();
  if (accesstoken_ == &::google::protobuf::internal::kEmptyString) {
    accesstoken_ = new ::std::string;
  }
  accesstoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLogin::mutable_accesstoken() {
  set_has_accesstoken();
  if (accesstoken_ == &::google::protobuf::internal::kEmptyString) {
    accesstoken_ = new ::std::string;
  }
  return accesstoken_;
}
inline ::std::string* ClientLogin::release_accesstoken() {
  clear_has_accesstoken();
  if (accesstoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accesstoken_;
    accesstoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLogin::set_allocated_accesstoken(::std::string* accesstoken) {
  if (accesstoken_ != &::google::protobuf::internal::kEmptyString) {
    delete accesstoken_;
  }
  if (accesstoken) {
    set_has_accesstoken();
    accesstoken_ = accesstoken;
  } else {
    clear_has_accesstoken();
    accesstoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLogout

// optional int64 uid = 1;
inline bool UserLogout::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogout::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogout::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogout::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 UserLogout::uid() const {
  return uid_;
}
inline void UserLogout::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// UserHeartRequest

// optional int64 pid = 1;
inline bool UserHeartRequest::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHeartRequest::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHeartRequest::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHeartRequest::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 UserHeartRequest::pid() const {
  return pid_;
}
inline void UserHeartRequest::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Message

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MessageUser_2eproto__INCLUDED
